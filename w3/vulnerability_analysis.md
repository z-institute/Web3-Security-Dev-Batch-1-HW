# Lender

## Vulnerability Analysis

- 每個 LenderPool 合約僅針對某一個 ERC20 Token 建立資金池
- poolBalance 是合約的變數，紀錄資金池的 balance，這個值可以透過 depositTokens 功能來增加
- 但這個值和 balanceOf(address(LenderPool)) 可能會不一樣，因為 balanceOf 的變動，不會更新到 poolBalance，只要透過外部的 transfer 到 address(LenderPool)，這兩個值就不會相等
- 進而造成 flashLoan 功能裡的斷言 assert(poolBalance == balanceBefore); 失敗，等同 flashLoan 功能永遠不能使用，這便是這個合約的 DOS 攻擊重點
- 就 testExploit() 提供的 vm.expectRevert(stdError.assertionError); 可以知道，這作業最後會因為 assert 不符合而 revert

### Mitigation

- 我認為的解法，就是設計代理 delegate 能記錄某個 address 把多少數量的 Dao Token 所代表的票數，請某個 address 來代理，例如: mapping(uint32 => mapping(address => mapping(address => uint256))) public ProposalFromToDelegated;
- 如果投票時，一定要保證每個 Dao Token 持有者 BalanceOf 的數量和 delegated 數量相符，那可以再寫一個 function，去 loop 更新每個 From address 的 BalanceOf(daoToken) 去取代 ProposalFromToDelegated 代理的數量
